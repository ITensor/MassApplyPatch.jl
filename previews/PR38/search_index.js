var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#MassApplyPatch.add_compat_entries!-Tuple{AbstractString}","page":"Reference","title":"MassApplyPatch.add_compat_entries!","text":"add_compat_entries!(project_toml; include_weakdeps=true, include_julia=nothing)\n\nAdd missing [compat] entries in a Project.toml file. Existing [compat] entries are preserved as-is.\n\nMissing entries are computed as:\n\npackage names in [deps] (and optionally [weakdeps])\nminus existing package names in [compat]\n\nBy default, julia compat is added only for package projects (those with both name and uuid fields). For sub-environments like test/docs/examples, julia compat is skipped unless include_julia=true is passed explicitly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.allow_automerge!","page":"Reference","title":"MassApplyPatch.allow_automerge!","text":"allow_automerge!(repos, enable::Bool = true; token=ENV[\"GITHUB_TOKEN\"], api=GitHub.DEFAULT_API)\n\nEnable or disable the repository-level \"Allow auto-merge\" setting for each \"OWNER/REPO\" in repos, for example allow_automerge!([\"ITensor/SparseArraysBase.jl\"], true) to enable it or allow_automerge!([\"ITensor/SparseArraysBase.jl\"], false) to disable it.\n\nReturns: Dict(\"OWNER/REPO\" => (ok::Bool, status::Int, message::String))\n\n\n\n\n\n","category":"function"},{"location":"reference/#MassApplyPatch.close_issue!-Tuple{AbstractString}","page":"Reference","title":"MassApplyPatch.close_issue!","text":"close_issue!(issue; delete_branch=false, comment=nothing, ignore_errors=true)\n\nClose a GitHub issue or pull request using the gh CLI.\n\nissue may be an issue/PR URL like:\n\nhttps://github.com/ORG/REPO/issues/123\nhttps://github.com/ORG/REPO/pull/123 or any identifier accepted by gh issue close / gh pr close.\n\nIf issue points to a PR and delete_branch=true, the PR branch is deleted after close. If comment is provided, posts a comment after closing. Returns true if the close command succeeded, false otherwise (unless ignore_errors=false).\n\nRequires: gh installed and authenticated (gh auth login).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.close_issues!-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.close_issues!","text":"close_issues!(issues; kwargs...)\n\nClose multiple GitHub issues/PRs. Returns a Vector{Bool} of close results.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.close_pr!-Tuple{AbstractString}","page":"Reference","title":"MassApplyPatch.close_pr!","text":"close_pr!(pr; delete_branch=false, comment=nothing, ignore_errors=true)\n\nBackward-compatible wrapper for closing a pull request. Uses close_issue!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.close_prs!-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.close_prs!","text":"close_prs!(prs; kwargs...)\n\nBackward-compatible wrapper for closing multiple pull requests. Uses close_issues!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.delete_branches!-Tuple{Function, AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.delete_branches!","text":"delete_branches!(f, repos; ignore_errors=true, api=GitHub.DEFAULT_API)\n\nDelete branches in each repository from repos when f(branch_name) is true.\n\nrepos should contain entries like \"OWNER/REPO\".\n\nReturns a vector of named tuples: (repo, branch, ok, status, message).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.disable_automerges!-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.disable_automerges!","text":"disable_automerges!(pr_urls::AbstractVector{<:AbstractString})\n\nDisable auto-merge for the given PR URLs via gh pr merge --disable-auto.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.filter_open_issues-Tuple{AbstractVector{<:AbstractString}, Function}","page":"Reference","title":"MassApplyPatch.filter_open_issues","text":"filter_open_issues(\n    repos::AbstractVector{<:AbstractString}, predicate::Function;\n    sort=\"updated\", direction=\"desc\"\n)\n\nReturn a flattened Vector of open issues from all repos that satisfy predicate. predicate should accept a named tuple (url, title, body).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.main-Tuple{Any}","page":"Reference","title":"MassApplyPatch.main","text":"MassApplyPatch.main(argv)\n\nCommand line interface for MassApplyPatch.\n\nArguments:\n\nargv: Command line arguments. Expected format: massapplypatch <org/repo>... –patch=<patchname>... [–notrigger-patch=<patchname>...] [–branch=branchname] [–title=prtitle] [–body=prbody]\n\nThe patch function should be provided as a Julia file, which is included and must define a function patch(repo_path).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.merge_prs!-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.merge_prs!","text":"merge_prs!(pr_urls::AbstractVector{<:AbstractString}; kwargs...)\n\nMerge PRs via gh pr merge.\n\nKeyword arguments:\n\nforce::Bool=false: bypass requirements and merge immediately (false is equivalent to --auto, true is equivalent to --admin).\nmerge_method::AbstractString=\"squash\": merge strategy, one of \"merge\", \"squash\", or \"rebase\".\ncommit_title::Union{Nothing, String}=nothing: custom commit title (equivalent to --subject).\ncommit_message::Union{Nothing, String}=nothing: custom commit message (equivalent to --body).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.open_issues-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.open_issues","text":"open_issues(repos::AbstractVector{<:AbstractString}; sort=\"updated\", direction=\"desc\")\n\nReturn a Vector of named tuples (url, title, body) (all String) for all open issues in each repository of repos (format: \"OWNER/REPO\"), sorted by most recently updated first. Pull requests are excluded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.open_prs-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.open_prs","text":"open_prs(repos::AbstractVector{<:AbstractString}; sort=\"updated\", direction=\"desc\")\n\nReturn a Vector of named tuples (url, branch, title, body) (all String) for all open PRs in each repository of repos (format: \"OWNER/REPO\"), sorted by most recently updated first.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.pr_statuses-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.pr_statuses","text":"pr_statuses(prs::AbstractVector{<:AbstractString})\n\nReturn a Vector{String} of PR statuses in the same order as prs.\n\nAccepted PR formats:\n\n\"https://github.com/OWNER/REPO/pull/123\"\n\"OWNER/REPO#123\"\n\nStatuses are \"draft\" (when draft), otherwise \"open\" or \"closed\".\n\nRequires: gh installed and authenticated (gh auth login).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.protect_branch!-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.protect_branch!","text":"protect_branch!(repos;\n    checks::Vector{String},\n    branch::Union{Nothing,String}=nothing,\n    api::GitHub.GitHubAPI=GitHub.DEFAULT_API,\n    strict::Bool=true,\n    enforce_admins::Bool=false,\n    require_pr::Bool=true,\n    required_approvals::Int=1,\n    require_code_owner_reviews::Bool=false,\n    dismiss_stale_reviews::Bool=true,\n    require_linear_history::Bool=true,\n    allow_force_pushes::Bool=false,\n    allow_deletions::Bool=false,\n) -> Dict{String,Tuple{Bool,Int,String}}\n\nApply branch protection to each repo in repos.\n\nchecks are the required status check contexts (exact names).\nbranch=nothing means “use each repo's default branch”.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.reopen_issue!-Tuple{AbstractString}","page":"Reference","title":"MassApplyPatch.reopen_issue!","text":"reopen_issue!(issue; comment=nothing, ignore_errors=true)\n\nReopen a GitHub issue or pull request using the gh CLI.\n\nissue may be an issue/PR URL like:\n\nhttps://github.com/ORG/REPO/issues/123\nhttps://github.com/ORG/REPO/pull/123 or any identifier accepted by gh issue reopen / gh pr reopen.\n\nIf comment is provided, posts a comment after reopening. Returns true if the reopen command succeeded, false otherwise (unless ignore_errors=false).\n\nRequires: gh installed and authenticated (gh auth login).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.reopen_issues!-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.reopen_issues!","text":"reopen_issues!(issues; kwargs...)\n\nReopen multiple GitHub issues/PRs. Returns a Vector{Bool} of reopen results.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.trigger_workflow_dispatch!-Tuple{AbstractVector{<:AbstractString}, AbstractString}","page":"Reference","title":"MassApplyPatch.trigger_workflow_dispatch!","text":"trigger_workflow_dispatch!(\n  repos::AbstractVector{<:AbstractString},\n  workflow::AbstractString;\n  ref::Union{Nothing, AbstractString}=nothing,\n  inputs::AbstractDict=Dict{String, String}(),\n  api::GitHub.GitHubAPI=GitHub.DEFAULT_API,\n)\n\nTrigger a GitHub Actions workflow dispatch for each repository in repos.\n\nrepos should contain entries like \"OWNER/REPO\".\nworkflow can be a workflow file name (for example \"TagBot.yml\"), workflow name, or workflow ID.\nIf ref is nothing, each repository's default branch is used.\ninputs are optional workflow_dispatch inputs.\n\nReturns:\n\nDict(\"OWNER/REPO\" => (ok::Bool, status::Int, message::String, ref::String))\n\n\n\n\n\n","category":"method"},{"location":"#MassApplyPatch.jl","page":"Home","title":"MassApplyPatch.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style) (Image: Aqua)","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n\nMassApplyPatch.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"section"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.\n\njulia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\")\n\nor:\n\njulia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\")\n\nif you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.\n\nThen, the package can be added as usual through the package manager:\n\njulia> Pkg.add(\"MassApplyPatch\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using MassApplyPatch: MassApplyPatch\n\nExamples go here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
