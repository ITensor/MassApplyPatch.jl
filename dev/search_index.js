var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#MassApplyPatch.allow_automerge!","page":"Reference","title":"MassApplyPatch.allow_automerge!","text":"allow_automerge!(repos, enable::Bool = true; token=ENV[\"GITHUB_TOKEN\"], api=GitHub.DEFAULT_API)\n\nEnable or disable the repository-level \"Allow auto-merge\" setting for each \"OWNER/REPO\" in repos, for example allow_automerge!([\"ITensor/SparseArraysBase.jl\"], true) to enable it or allow_automerge!([\"ITensor/SparseArraysBase.jl\"], false) to disable it.\n\nReturns: Dict(\"OWNER/REPO\" => (ok::Bool, status::Int, message::String))\n\n\n\n\n\n","category":"function"},{"location":"reference/#MassApplyPatch.close_pr!-Tuple{AbstractString}","page":"Reference","title":"MassApplyPatch.close_pr!","text":"close_pr!(pr; delete_branch=false, comment=nothing, ignore_errors=true)\n\nClose a GitHub pull request using the gh CLI.\n\npr may be a PR URL like https://github.com/ORG/REPO/pull/123 (recommended), a PR number, or any identifier accepted by gh pr close.\n\nIf comment is provided, posts a PR comment after closing. Returns true if the close command succeeded, false otherwise (unless ignore_errors=false).\n\nRequires: gh installed and authenticated (gh auth login).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.close_prs!-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.close_prs!","text":"close_prs!(prs; kwargs...)\n\nClose multiple PRs. Returns a Vector{Bool} of close results.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.disable_automerges!-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.disable_automerges!","text":"disable_automerges!(pr_urls::AbstractVector{<:AbstractString})\n\nDisable auto-merge for the given PR URLs via gh pr merge --disable-auto.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.main-Tuple{Any}","page":"Reference","title":"MassApplyPatch.main","text":"MassApplyPatch.main(argv)\n\nCommand line interface for MassApplyPatch.\n\nArguments:\n\nargv: Command line arguments. Expected format: massapplypatch <org/repo>... –patch=<patchname>... [–notrigger-patch=<patchname>...] [–branch=branchname] [–title=prtitle] [–body=prbody]\n\nThe patch function should be provided as a Julia file, which is included and must define a function patch(repo_path).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.merge_prs!-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.merge_prs!","text":"merge_prs!(pr_urls::AbstractVector{<:AbstractString}; kwargs...)\n\nMerge PRs via gh pr merge.\n\nKeyword arguments:\n\nforce::Bool=false: bypass requirements and merge immediately (false is equivalent to --auto, true is equivalent to --admin).\nmerge_method::AbstractString=\"squash\": merge strategy, one of \"merge\", \"squash\", or \"rebase\".\ncommit_title::Union{Nothing, String}=nothing: custom commit title (equivalent to --subject).\ncommit_message::Union{Nothing, String}=nothing: custom commit message (equivalent to --body).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.open_prs-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.open_prs","text":"open_prs(repos::AbstractVector{<:AbstractString}; sort=\"updated\", direction=\"desc\")\n\nReturn a Vector of named tuples (url, branch, title, body) (all String) for all open PRs in repo (format: \"OWNER/REPO\"), sorted by most recently updated first.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.pr_statuses-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.pr_statuses","text":"pr_statuses(prs::AbstractVector{<:AbstractString})\n\nReturn a Vector{String} of PR statuses in the same order as prs.\n\nAccepted PR formats:\n\n\"https://github.com/OWNER/REPO/pull/123\"\n\"OWNER/REPO#123\"\n\nStatuses are \"draft\" (when draft), otherwise \"open\" or \"closed\".\n\nRequires: gh installed and authenticated (gh auth login).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.protect_branch!-Tuple{AbstractVector{<:AbstractString}}","page":"Reference","title":"MassApplyPatch.protect_branch!","text":"protect_branch!(repos;\n    checks::Vector{String},\n    branch::Union{Nothing,String}=nothing,\n    api::GitHub.GitHubAPI=GitHub.DEFAULT_API,\n    strict::Bool=true,\n    enforce_admins::Bool=false,\n    require_pr::Bool=true,\n    required_approvals::Int=1,\n    require_code_owner_reviews::Bool=false,\n    dismiss_stale_reviews::Bool=true,\n    require_linear_history::Bool=true,\n    allow_force_pushes::Bool=false,\n    allow_deletions::Bool=false,\n) -> Dict{String,Tuple{Bool,Int,String}}\n\nApply branch protection to each repo in repos.\n\nchecks are the required status check contexts (exact names).\nbranch=nothing means “use each repo's default branch”.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MassApplyPatch.trigger_workflow_dispatch!-Tuple{AbstractVector{<:AbstractString}, AbstractString}","page":"Reference","title":"MassApplyPatch.trigger_workflow_dispatch!","text":"trigger_workflow_dispatch!(\n  repos::AbstractVector{<:AbstractString},\n  workflow::AbstractString;\n  ref::Union{Nothing, AbstractString}=nothing,\n  inputs::AbstractDict=Dict{String, String}(),\n  api::GitHub.GitHubAPI=GitHub.DEFAULT_API,\n)\n\nTrigger a GitHub Actions workflow dispatch for each repository in repos.\n\nrepos should contain entries like \"OWNER/REPO\".\nworkflow can be a workflow file name (for example \"TagBot.yml\"), workflow name, or workflow ID.\nIf ref is nothing, each repository's default branch is used.\ninputs are optional workflow_dispatch inputs.\n\nReturns:\n\nDict(\"OWNER/REPO\" => (ok::Bool, status::Int, message::String, ref::String))\n\n\n\n\n\n","category":"method"},{"location":"#MassApplyPatch.jl","page":"Home","title":"MassApplyPatch.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style) (Image: Aqua)","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n\nMassApplyPatch.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"section"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.\n\njulia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\")\n\nor:\n\njulia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\")\n\nif you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.\n\nThen, the package can be added as usual through the package manager:\n\njulia> Pkg.add(\"MassApplyPatch\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using MassApplyPatch: MassApplyPatch\n\nExamples go here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
